{"version":3,"sources":["Node/Node.jsx","Algorithms/dijkstras.js","Algorithms/astar.js","Node/reset.js","PathfindingVisualizer/PathfindingVisualizer.jsx","Navbar/Navbar.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","row","isStart","isFinish","isWall","onMouseDown","onMouseUp","onMouseEnter","extraClassName","id","className","Component","getUnvisitedNeighbors","node","grid","neighbors","push","length","filter","isVisited","dijkstra","startNode","endNode","visitedNodes","distance","unvistedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","unvisitedNeighbors","neighbor","previousNode","sort","nodeA","nodeB","closedList","openList","includes","gCost","hCost","manhattanHeuristic","fCost","Math","abs","resetTimeOutEvents","timeOutEvents","events","clearTimeout","resetGrid","typeOfReset","newGrid","currentRow","temp","document","getElementById","START_NODE_ROW","START_NODE_COL","END_NODE_ROW","END_NODE_COL","PathfindingVisualizer","setWalls","slice","newNode","state","isMousePressed","initializeGrid","setState","typeOfAlgorithm","visitedNodesInOrder","astar","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animate","i","setTimeout","animateShortestPath","createNode","clearAll","onClick","handleVisualize","handleClearAll","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","Navbar","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fbfb9b61.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      row,\n      isStart,\n      isFinish,\n      isWall,\n      onMouseDown,\n      onMouseUp,\n      onMouseEnter\n    } = this.props;\n    // Triple ternary\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseUp={() => onMouseUp()}\n        onMouseEnter={() => onMouseEnter(row, col)}\n      ></div>\n    );\n  }\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n\n  if (row > 0) neighbors.push(grid[row - 1][col]); // Top\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // Bottom\n  if (col > 0) neighbors.push(grid[row][col - 1]); // Left\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // Right\n  return neighbors.filter(node => !node.isVisited); // Return all neighbors not visited\n}\n\nexport function getNodesInShortestPathOrder(endNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}\n","import { getUnvisitedNeighbors } from \"../Node/Node\";\n\nexport function dijkstra(grid, startNode, endNode) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  const unvistedNodes = getAllNodes(grid);\n\n  while (!!unvistedNodes.length) {\n    sortNodesByDistance(unvistedNodes);\n    // Grab closest distanced node\n    const closestNode = unvistedNodes.shift();\n\n    // Case node is wall\n    if (closestNode.isWall) continue;\n\n    // Case trapped\n    if (closestNode.distance === Infinity) {\n      // Animate last node by adding extra object\n      visitedNodes.push({});\n      return visitedNodes;\n    }\n\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n\n    if (closestNode === endNode) return visitedNodes;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1; // Central node + 1 for surronding nodes\n    neighbor.previousNode = node; // Set point to backtrack\n  }\n}\n\nfunction sortNodesByDistance(unvistedNodes) {\n  unvistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n","import { getUnvisitedNeighbors } from \"../Node/Node\";\n\n\nexport function astar(grid, startNode, endNode) {\n  // Initialize\n  const closedList = [];\n  startNode.gCost = 0;\n  const openList = [];\n\n  // Push startnode\n  openList.push(startNode);\n\n  while (!!openList.length) {\n    sortNodesByFCost(openList)\n    // Get lowest fCost node\n    const closestNode = openList.shift();\n\n    // Save order of nodes\n    closedList.push(closestNode);\n    closestNode.isVisited = true;\n\n    if (closestNode === endNode) return closedList;\n    updateUnvisitedNeighbors(closestNode, grid, endNode, closedList, openList);\n  }\n  closedList.push({});\n  return closedList;\n}\n\nfunction updateUnvisitedNeighbors(node, grid, endNode, closedList, openList) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    // Neighbor is in closedList\n    if (closedList.includes(neighbor) || neighbor.isWall) continue;\n\n    // Set g, h, f costs\n    neighbor.gCost = node.gCost + 1;\n    neighbor.hCost = manhattanHeuristic(neighbor, endNode);\n    neighbor.fCost = neighbor.gCost + neighbor.hCost;\n    neighbor.previousNode = node;\n\n    // Neighbor is in openList\n    if (openList.includes(neighbor)) continue;\n    openList.push(neighbor);\n  }\n}\n\nfunction manhattanHeuristic(node, endNode) {\n  // Utilize the Manhattan Distance -- allows for 4 directional movement (up, down, left, right)\n  return Math.abs(node.row - endNode.row) + Math.abs(node.col - endNode.col);\n}\n\nfunction sortNodesByFCost(nodes) {\n    nodes.sort((nodeA, nodeB) => nodeA.fCost - nodeB.fCost)\n}","export function resetTimeOutEvents(timeOutEvents) {\n  //reset set time out events\n  for (const events of timeOutEvents) {\n    clearTimeout(events);\n  }\n  timeOutEvents = [];\n}\n\nexport function clearAll(grid) {\n    //clear all className tags but keep special nodes\n  const newGrid = [];\n  for (let row of grid) {\n    for (let node of row) {\n      const extraClassName = node.isFinish\n        ? \"node-finish\"\n        : node.isStart\n        ? \"node-start\"\n        : node.isWall\n        ? \"node-wall\"\n        : \"\";\n\n      if (!node.isStart || !node.isFinish) {\n        document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className = `node ${extraClassName}`;\n      }\n    }\n  }\n  return newGrid;\n}\n\nexport function resetGrid(grid, typeOfReset) {\n    //reset grid either with wall or without\n  const newGrid = [];\n  for (let row of grid) {\n    const currentRow = [];\n    for (let node of row) {\n      let temp;\n      typeOfReset === \"withWalls\" ? (temp = node.isWall) : (temp = false);\n\n      currentRow.push({\n        row: node.row,\n        col: node.col,\n        isWall: temp,\n        isStart: node.isStart,\n        isFinish: node.isFinish,\n        distance: Infinity,\n        isVisited: false,\n        previousNode: null,\n        gCost: Infinity,\n        hCost: Infinity,\n        fCost: Infinity\n      });\n      const extraClassName = node.isFinish\n        ? \"node-finish\"\n        : node.isStart\n        ? \"node-start\"\n        : node.isWall\n        ? \"node-wall\"\n        : \"\";\n\n      if (!node.isStart || !node.isFinish) {\n        document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className = `node ${extraClassName}`;\n      }\n    }\n    newGrid.push(currentRow);\n  }\n  return newGrid;\n}\n","import React, { Component } from \"react\";\nimport Node from \"../Node/Node\";\n\nimport \"./PathfindingVisualizer.css\";\nimport { getNodesInShortestPathOrder } from \"../Node/Node\";\nimport { dijkstra } from \"../Algorithms/dijkstras\";\nimport { astar } from \"../Algorithms/astar\";\nimport { resetGrid, resetTimeOutEvents, clearAll } from \"../Node/reset\"\n\n\n// Constants for start and end nodes\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst END_NODE_ROW = 10;\nconst END_NODE_COL = 35;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      isMousePressed: false\n    };\n    this.timeOutEvents = [];\n  }\n\n  componentDidMount() {\n    // Initialize grid\n    const grid = this.initializeGrid();\n    this.setState({ grid });\n  }\n\n  handleVisualize(typeOfAlgorithm) {\n    // Stops all current animation\n    resetTimeOutEvents(this.timeOutEvents);\n    const { grid } = this.state;\n\n    // Reset grid but keep walls\n    const newGrid = resetGrid(grid, 'withWalls');\n\n    const startNode = newGrid[START_NODE_ROW][START_NODE_COL];\n    const endNode = newGrid[END_NODE_ROW][END_NODE_COL];\n    const visitedNodesInOrder =\n      typeOfAlgorithm === \"dijkstra\"\n        ? dijkstra(newGrid, startNode, endNode)\n        : astar(newGrid, startNode, endNode);\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 1; i <= visitedNodesInOrder.length - 1; i++) {\n      if (i === visitedNodesInOrder.length - 1) {\n        this.timeOutEvents.push(setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 12 * i));\n      } else {\n        this.timeOutEvents.push(setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }, 12 * i));\n      }\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\n        this.timeOutEvents.push(setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i));\n    }\n  }\n\n  createNode(row, col) {\n    return {\n      row,\n      col,\n      isWall: false,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === END_NODE_ROW && col === END_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      previousNode: null,\n      gCost: Infinity,\n      hCost: Infinity,\n      fCost: Infinity\n    };\n  }\n\n  initializeGrid() {\n    const grid = [];\n    for (let row = 0; row < 20; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(this.createNode(row, col));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = this.setWalls(this.state.grid, row, col);\n    this.setState({ grid: newGrid, isMousePressed: true });\n  }\n\n  handleMouseUp() {\n    this.setState({ isMousePressed: false });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isMousePressed) return;\n    const newGrid = this.setWalls(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  setWalls = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    let newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n\n    // Case walls on start and end nodes\n    newGrid[START_NODE_ROW][START_NODE_COL].isWall = false;\n    newGrid[END_NODE_ROW][END_NODE_COL].isWall = false;\n\n    return newGrid;\n  };\n\n  handleClearAll(grid) {\n    // Clear everything on grid\n    resetTimeOutEvents(this.timeOutEvents)\n    let newGrid = resetGrid(grid, 'withoutWalls')\n    this.setState({grid: newGrid})\n    clearAll(newGrid)\n  }\n\n  render() {\n    const { grid, isMousePressed } = this.state;\n    return (\n      <div className='content-container'>\n        <div className='button-container'>\n          <button onClick={() => this.handleVisualize(\"dijkstra\")}>\n            Visualize Dijkstra's Algorithm\n          </button>\n          <button onClick={() => this.handleVisualize(\"astar\")}>\n            Visualize A* Search Algorithm\n          </button>\n          <button onClick={() => this.handleClearAll(grid)}>\n            Clear All\n          </button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { isStart, isFinish, isWall, col, row } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      row={row}\n                      isStart={isStart}\n                      isFinish={isFinish}\n                      isWall={isWall}\n                      isMousePressed={isMousePressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={(row, col) => this.handleMouseUp(row, col)}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react'\n\nimport \"./Navbar.css\"\n\nexport default class Navbar extends Component {\n    render() {\n        return (\n            <div className=\"navbar\">\n                <p>Pathfinding Visualizer</p>\n            </div>\n        )\n    }\n}\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\nimport Navbar from './Navbar/Navbar'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Navbar />\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}